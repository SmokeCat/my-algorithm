# 62. 不同路径
https://leetcode-cn.com/problems/unique-paths/

## 题目描述

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角

问总共有多少条不同的路径？

说明：m 和 n 的值均不超过 100。

示例 1:
```
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右
```

示例 2:
```
输入: m = 7, n = 3
输出: 28
```

## 题解

### 解决思路：

动态规划，每一个格子保存到达当前格子的路径数，其中第一行和第一列为1，其他的路径数等于左边格子和上边格子路径数之和。

### 代码

java代码:
~~~ java
class Solution {
    public int uniquePaths(int m, int n) {
    	if(m == 0 || n == 0) return 0;
    	else if(n == 1 || m == 1) return 1;
    	
    	int[][] paths = new int[m][n];
    	
    	for(int i = 0; i < m; i++){
    		for(int j = 0; j < n; j++){
    			if(i == 0 || j == 0){
    				paths[i][j] = 1;
    			}else{
    				paths[i][j] = paths[i-1][j] + paths[i][j-1];
    			}
    		}
    	}
    	
		return paths[m-1][n-1];
    }
}
~~~

### 复杂度分析：

时间复杂度：$O(mn)$

空间复杂度：$O(mn)$

## 其他方法1

### 思路

优化空间，只需要依赖当前行和上一行的路径数，维护两个长度为n的一位数组。

其中上一行可以再优化掉，每一次计算当前路径数时，只需要在当前数之上的那个数，可以保存在当前位置中。

### 关键代码

~~~ java
    // 将原来步骤中的paths[i][j] = paths[i-1][j] + paths[i][j-1];优化为以下
    path[j] == path[j] + path[j-1]
~~~

### 复杂度分析：

时间复杂度：$O(mn)$

空间复杂度：$O(n)$
